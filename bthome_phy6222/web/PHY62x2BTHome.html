<html class="telFlasherClass"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PHY62x2-BTHome тест версия</title>
</head>
<body>
<script>
//BLE values
const FLASH_SIZE = 0x80000;
var bluetoothDevice, gattServer, otaCharacteristic, myCharacteristic;
//Firmware values
var firmwareArray = null,
    startTime = 0,
    flgRdFF = false,
    fwmaxsize = 196608,
    fwname = "",
    blockCount = 0;
//Connection values
var connectTrys = 0;

var $ = function(id) { return document.getElementById(id);}

function resetVariables() {
    busy = false;
    gattServer = null;
    Theservice = null;
    otaCharacteristic = null;
    myCharacteristic = null;
    $('butReadAddr').disabled = true;
    $('butStartDFU').disabled = true;
    $('butWriteData').disabled = true;
    $('butCmdData').disabled = true;
}

function handleError(error) {
    addLog(error);
    resetVariables();
    if (connectTrys < 5) {
        connectTrys++;
        addLog("Переподключение " + connectTrys + " из " + 5);
        doConnect();
    } else {
        addLog("Подключится не удалось!");
        connectTrys = 0;
    }
}

function onDisconnected() {
    addLog('Disconnected.');
}

function connect() {
	var deviceOptions = {
		optionalServices: [0xfff0],
		services: [0x180a, 0x181c, 0x181e, 0xfff0],
		acceptAllDevices: true };
	const namePrefix = $('namePrefix').value;
	if (namePrefix) {
		deviceOptions.acceptAllDevices = false;
		deviceOptions.filters = namePrefix.split(",")
			.map((x) => ({ namePrefix: x }));
	} else {
		deviceOptions.acceptAllDevices = false;
		deviceOptions.filters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz_#@!*0123456789';,.<>{}[]"
			.split("")
			.map((x) => ({ namePrefix: x }));
	}
    if (bluetoothDevice != null) bluetoothDevice.gatt.disconnect();
    resetVariables();
    addLog("Поиск устройств");
    connectTrys = 0;
    navigator.bluetooth.requestDevice(deviceOptions).then(device => {
        bluetoothDevice = device;
        bluetoothDevice.addEventListener('gattserverdisconnected', onDisconnected);
        addLog("Connecting to: " + bluetoothDevice.name);
        doConnect();
    }).catch(handleError);
}


function doConnect() {
    bluetoothDevice.gatt.connect().then(server => {
        addClog("Найден GATT сервер");
        gattServer = server;
        return gattServer.getPrimaryService(0xfff0);
    }).then(service => {
        addClog("Найден Main сервис");
        Theservice = service;
        return service.getCharacteristic(0xfff3);
    }).then(characteristic => {
        addClog("Найдена OTA характеристика");
        otaCharacteristic = characteristic;
		return otaCharacteristic.addEventListener('characteristicvaluechanged', event => OtaBlkParse(event.target.value));
	}).then(_ => {
        return otaCharacteristic.readValue();
    }).then(value => {
		if(value.byteLength >= 20)
			addLog("OTA: "+dump8(value, value.byteLength));
        return Theservice.getCharacteristic(0xfff4);
    }).then(characteristic => {
        addClog("Найдена CMD характеристика");
        myCharacteristic = characteristic;
        return myCharacteristic.readValue();
    }).then(value => {
		if(value.byteLength >= 10)
			addLog("DevCfg: "+dump8(value, value.byteLength));
		return myCharacteristic.addEventListener('characteristicvaluechanged', event => CustomBlkParse(event.target.value));
	}).then(_ => {
		myCharacteristic.startNotifications().then(_ => {
        	let s = "Устройство подключено.";
			addAlog(s);
		    $('butCmdData').disabled = false;
			$('butReadAddr').disabled = false;
			$('butWriteData').disabled = false;	
			if (firmwareArray != null) $('butStartDFU').disabled = false;
			})
    }).catch(handleError);
}

function reConnect() {
    if (bluetoothDevice != null) bluetoothDevice.gatt.disconnect();
    resetVariables();
    addLog("Reconnect");
    connectTrys = 0;
    doConnect();
}

function startDFU() {
    addLog("Старт программирования...");
    updateBegin();
}

function addLog(logTXT) {
    console.log(logTXT)
    var time = new Date().toLocaleTimeString();
    var logString = time + ": " + logTXT;
    $("log").innerHTML += logString + "<br>";
}

function addClog(logTXT) {
    console.log(logTXT);
}

function addAlog(logTXT) {
    addLog(logTXT);
    setStatus(logTXT);
}

function clearLog() {
    $("log").innerHTML = "";
}

function setStatus(status) {
//    addClog("Status: " + status);
    $("percent").innerHTML = "Статус: " + status;
}

function updateFail(err) {
    let s = "OTA error: " + err;
    addAlog(s);
}

function decimalToHex(d, padding) {
    var hex = Number(d).toString(16);
    while (hex.length < 4) {
        hex = "0" + hex;
    }
    return hex;
}

function hexToBytes(hex) {
    for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
    return new Uint8Array(bytes);
}

function bytesToHex(data) {
    return new Uint8Array(data).reduce(function(memo, i) {
        return memo + ("0" + i.toString(16)).slice(-2);
    }, "");
}

function crc16_modbus(buffer) {
    var crc = 0xFFFF;
    var odd;
    for (var i = 0; i < buffer.length; i++) {
        crc = crc ^ buffer[i];
        for (var j = 0; j < 8; j++) {
            odd = crc & 0x0001;
            crc = crc >> 1;
            if (odd) {
                crc = crc ^ 0xA001;
            }
        }
    }
    return crc;
};

function getHexCRC(data) {
    var tempCRC = decimalToHex(crc16_modbus(hexToBytes(data)));
    return tempCRC.substring(2, 4) + tempCRC.substring(0, 2);
}

function makeRandomID(length) {
    var result = '';
    var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var charactersLength = characters.length;
    for (var i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return bytesToHex(new TextEncoder("utf-8").encode(result));
}

function hex(number, len) {
	var str = (number.toString(16)).toUpperCase();
	while (str.length < len) str = '0' + str;
	return str;
}

function hexToBytes(hex) {
	for (var bytes = [], c = 0; c < hex.length; c += 2)
		bytes.push(parseInt(hex.substr(c, 2), 16));
	return new Uint8Array(bytes);
}

function dump(ar, len) {
	let s = '';
	for(let i=0; i < len; i++) {
		s += hex(ar[i],2);
	}
	return s;
}

function dump8(ar, len) {
	let s = '';
	for(let i=0; i < len; i++) {
		s += hex(ar.getUint8(i),2);
	}
	return s;
}

function hex2ascii(hexx) {
    var hex = hexx.toString();
    var str = '';
    for (var i = 0;
        (i < hex.length && hex.substr(i, 2) !== '00'); i += 2)
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    return str;
}

var crc32 = (function() {
	let table = new Uint32Array(256);
	for(var i=256; i--;) {
		let tmp = i;
		for(let k=8; k--;) {
			tmp = tmp & 1 ? 0xEDB88320 ^ tmp >>> 1 : tmp >>> 1;
		}
		table[i] = tmp;
	}
	return function( data ) {
		let crc = -1;
		let l = data.length;
		for(let i=0; i<l; i++) {
			crc = crc >>> 8 ^ table[ crc & 255 ^ data[i] ];
		}
		return (crc >>> 0);
	};
})();

function testOTAFirmware(data) {
	let fsize = data.byteLength;
	addClog("File size = 0x"+ fsize.toString(16));
	if (fsize < 272)
		return "Неправильный размер двоичной прошивки PHY6 OTA!";
	if(fsize > 192*1024) // 208kB for BLE
		return "Размер прошивки более 192 кбайт!";
	let head = new DataView(data, 0, 272);
	let h = {};
	h.id = head.getUint32(0, true);
	h.segs = head.getUint32(4, true);
	h.start = head.getUint32(8, true);
	h.size = head.getUint32(12, true);
	addAlog("PHY6 OTA ID: "+hex(h.id, 4)+ ", Сегментов: " + h.segs + ", Старт: 0x"+hex(h.start, 8)+ ", Размер: " + h.size + " байт");
	if(h.id != 0x36594850) // "PHY6"
		return "Неверное id в заголовке PHY6 OTA!";
	if(h.segs > 16)
		return "Неверное количество сегментов в заголовке PHY6 OTA!";
	if(h.size != fsize-4)
		return "Неверный размер в заголовке PHY6 OTA!";
	let fcrc = new Uint32Array(2);
	fcrc[0] = crc32(new Uint8Array(data.slice(0, h.size)));
	let x = new DataView(data, h.size, 4);
	fcrc[1] = x.getUint32(0, true);
	addClog("Файл CRC = 0x" + fcrc[1].toString(16) + ", Расчет CRC = 0x" + fcrc[0].toString(16));
	if(fcrc[0] != fcrc[1]) {
		return "Неправильный CRC в файле OTA!";
	}
	return "ok";
}

function getFirmwareArray(data, filename) {
	addAlog("Файл: " + filename);
	addClog("Файл: " + filename);
	let s = testOTAFirmware(data);
	if(s != "ok") {
		addAlog(s);
		blockCount = 0;
		firmwareArray = null;
		fwname = "";
		//$("ldfrmw").innerHTML=s;
		alert(s);
		return;
	}
	firmwareArray = bytesToHex(data);
	addAlog("Размер файла: " + (firmwareArray.length/2).toString(10) + " байт");
	if (firmwareArray.length % 32 !== 0) { // pad last block to 16bytes
		var padHex = "ffffffffffffffffffffffffffffffff";
		firmwareArray += padHex.substr(0, 32 - firmwareArray.length % 32);
	}
	blockCount = firmwareArray.length / 32;
	addAlog("Счетчик: " + blockCount + " блоков");
	fwname = filename;
	$('butStartDFU').disabled = false;
}

window.onload = function() {
    document.querySelector("#file").addEventListener("change", function() {
    	let reader = new FileReader();
		reader.fname = "";
		reader.onload = function() {getFirmwareArray(this.result, this.fname);};
    	if (this.files[0] != null)
        	reader.readAsArrayBuffer(this.files[0]);
	    else
    	    addLog("Файл не выбран"); }, false);
}

var ota_errors = [
'ok',
'Неверная команда',
'Не задан старт',
'Не заданы параметры',
'Неверные параметры',
'Неправильный размер пакета',
'Ошибка CRC16 пакета',
'Потеря пакетов',
'Ошибка записи в Flash',
'Ошибка в номере пакета',
'Ошибка идентификатора в файле программы',
'Ошибка CRC32 переданной программы'];

function get_msg_ota_err(err) {
	if(err == 0)
		return "ok";
 	if(err == 255)
		return "OTA end";
	if(err <= 11)
		return ota_errors[err];
	return "Неизвестная ошибка";
}

function OtaBlkParse(value) {
	if(value.byteLength < 20) return;
	var ota = {};
	ota.err_flag = value.getUint8(0);
	ota.version = value.getUint8(1);
	ota.start_flag = value.getUint8(2);
	ota.debug_flag = value.getUint8(3);
	ota.program_offset = value.getUint32(4,true);
	ota.pkt_index = value.getUint16(8,true);
	ota.pkt_total = value.getUint16(10,true);
	ota.fw_value = value.getUint32(12,true);
	ota.crc32 = value.getUint32(16,true);
	//addClog('otablk: '+dump8(value, value.byteLength));
	addClog('OTA read: ver: '+hex(ota.version,2)+', err: '+ota.err_flag+' - '+get_msg_ota_err(ota.err_flag)+', dbg: '+ota.debug_flag+', start: '+ota.start_flag+', offs: 0x'+hex(ota.program_offset,8)+', idx: 0x'+hex(ota.pkt_index,4)+', total: 0x'+hex(ota.pkt_total,4)+', crc: 0x'+hex(ota.crc32,8));
}

function updateBegin() {
    if (blockCount <= 0) {
        addLog("Не выбран файл!");
        return;
    }
    setTimeout(function() {
        otaCharSend("00ff")
        .then(_ => { otaCharacteristic.readValue().then(value => {
//        otaCharSend("01ff"+firmwareArray.substring(16,24)+firmwareArray.substring(0,8)+hex((blockCount >> 8) | ((blockCount & 0xff) << 8),4))
		otaCharSend("01ff")
        .then(_ => { otaCharacteristic.readValue().then(value => {
			if(value.byteLength >= 2 && value.getUint8(0) == 0) {
	        	setTimeout(function() {
    	        	startTime = new Date().getTime();
        	        sendOTAblock(0);
            	}, 100);
            } else
            	addAlog("Ошибка N"+value.getUint8(0)+" OTA!");
        }).catch(function(err) {updateFail(err); });
        }).catch(function(err) {updateFail(err); });
        }).catch(function(err) {updateFail(err); });
        }).catch(function(err) {updateFail(err); });
    }, 100);
}

function sendLastOTA() {
	otaCharacteristic.readValue().then(value => {
		if(value.byteLength >= 1 && value.getUint8(0) == 0xff)
		  	addAlog("Программирование завершено за " + (new Date().getTime() - startTime) / 1000 + " секунды");
		else
			addAlog("Ошибка ("+value.getUint8(0)+") OTA: " + get_msg_ota_err(value.getUint8(0)));
     }).catch(function(err) { updateFail(err); });
/*  Сброс - отключен для теста
    var data = "02ff";
    otaCharSend(data).then(_ => {
    	addAlog("Программирование завершено за " + (new Date().getTime() - startTime) / 1000 + " секунды");
    }).catch(function(err) {
        updateFail(err);
    }); */
}

function sendOTAblock(blockNr) {
    if (blockNr >= blockCount) {
        sendLastOTA();
        return;
    }
    setStatus("Передан блок N: " + blockNr + " из " + blockCount + ", " + Math.floor(blockNr / (blockCount * 1.0) * 100) + "% успеха, время от старта " + (new Date().getTime() - startTime) / 1000.0 + " сек");
    var blockNrString = getHexBLockCount(blockNr);
    var blockString = blockNrString + firmwareArray.substring(blockNr * 32, blockNr * 32 + 32);
    var blockCRC = getHexCRC(blockString);
    otaCharSend(blockString + blockCRC).then(_ => {
	    if (blockNr >= blockCount - 1) {
    	    sendLastOTA();
        	return;
	    }
        setTimeout(function() {
            if ((blockNr + 1) % 8 == 0) {
                otaCharacteristic.readValue().then(value => {
					if(value.byteLength >= 1 && value.getUint8(0) == 0)
	                    sendOTAblock(blockNr + 1);
		            else {
		            	let s = get_msg_ota_err(value.getUint8(0));
		            	if(s != "ok")
			            	addAlog("Ошибка ("+value.getUint8(0)+") на передаче блока "+blockNr+" OTA: "+s);
		            }
				}).catch(function(err) { updateFail(err); });
			} else
                  sendOTAblock(blockNr + 1);
        }, 0);
    }).catch(function(err) {
        updateFail(err);
    });
}

function getHexBLockCount(count) {
    var tempHEX = decimalToHex(count);
    return tempHEX.substring(2, 4) + tempHEX.substring(0, 2);
}


var otaCharSend = function(data) {
    return new Promise(function(resolve, reject) {
        //addClog("OTA send: " + data);
        otaCharacteristic.writeValue(hexToBytes(data)).then(function(character) {
            resolve("ok");
        }).catch(function(err) {
            reject("Ошибка при отправке данных");
        });
    });
}

var mainCharSend = function(data, characteristic) {
    return new Promise(function(resolve, reject) {
        addClog("Send: " + data);
        characteristic.writeValue(hexToBytes(data)).then(function(character) {
            resolve("ok");
        }).catch(function(err) {
            reject("Ошибка при отправке данных");
        });
    });
}

function ReadAddr(addr) {
	if(myCharacteristic) {
		let blk = new Uint8Array([0xdb, addr&0xff, (addr>>8)&0xff, (addr>>16)&0xff, (addr>>24)&0xff]);
		myCharacteristic.writeValue(blk).then(_ => {
			startTime = new Date().getTime();
			addAlog("Чтение 16 байт из 0x"+hex(addr,8)+"...");
		});
	}
}

function WriteAddr(addr, data) {
	if(myCharacteristic) {
		len = data.length;
		if(len != 0 && len <= 16) {
			let blk = new Uint8Array(len + 5);
			blk.set([0xdb, addr&0xff, (addr>>8)&0xff, (addr>>16)&0xff, (addr>>24)&0xff]);
			blk.set(data, 5);
			console.log(blk);
			addAlog("Запись "+len+" байт в 0x"+hex(addr,6)+"...");
			myCharacteristic.writeValue(blk);
		} else {
			console.log(data);
		        addClog('Должно быть от 1 до 16 байт!');
		}
	}
}


function InfoReadAddr() {
	if(myCharacteristic) {
		let faddr = parseInt($('inputAddr').value, 16);
		ReadAddr(faddr);
	}
}

function WriteCmd(data) {
	if(myCharacteristic) {
		len = data.length;
		if(len != 0 && len <= 20) {
			let blk = new Uint8Array(data);
			console.log(blk);
			myCharacteristic.writeValue(blk);
		} else {
			console.log(data);
	        addClog('Должно быть от 1 до 20 байт!');
		}
	}
}

function WriteData() {
	let addr = parseInt($('inputAddr').value, 16);
	let data = hexToBytes($('inputData').value);
	if(data.length != 0 && data.length <= 16)
		WriteAddr(addr, data);
	else
	    addClog('Должно быть от 1 до 16 hex байт!');

}

function CmdData() {
	let data = hexToBytes($('inputCmdData').value);
	if(data.length != 0 && data.length <= 20)
		WriteCmd(data);
	else
	    addClog('Должно быть от 1 до 20 hex байт!');
}


function CustomBlkParse(value) {
	let len = value.byteLength;
	if(len == 0) return;
	len--;	// size from cmd
	let blkid = value.getUint8(0);
	s = 'Ответ на команду id: '+hex(blkid,2)+' data: '+bytesToHex(value.buffer.slice(1));
	addLog(s);
	if(blkid == 0xdb && value.byteLength > 4) {
		len -= 4;
		let addr = value.getUint32(1,true);
		let s = bytesToHex(value.buffer.slice(5), len);
		$('inputData').value = s;
		addLog(hex(addr,8)+':'+s);
		setStatus("Считано "+len+" байт из 0x" + hex(addr,8)); 
	} else 
		addClog('blk: '+dump8(value, value.byteLength));
}

var url;
function download(data, filename, type) {
	var file = new Blob([data], {type: type});
	if (window.navigator.msSaveOrOpenBlob) { // ie10+
		window.navigator.msSaveOrOpenBlob(file, filename);
	} else { // ff, chrome
		url = URL.createObjectURL(file);
		let a = document.createElement("a");
		a.href = url;
		a.download = filename;
		document.body.appendChild(a);
		a.click();
		setTimeout(function(){document.body.removeChild(a);window.URL.revokeObjectURL(url);},0);
		URL.revokeObjectURL(url);
	}
}


</script>
<big><big>PHY62x2-BTHome</big></big> <a href="https://github.com/pvvx/THB2">&#9432;</a><hr>
<button type="button" onclick="connect();">Соединение</button>
<button type="button" onclick="reConnect();">Переподключение</button><br><br>
<label for="namePrefix">Префикс названия устройств(а)</label>
<input type="text" id="namePrefix" value="" placeholder="THB, BT"><br><hr>
Выбор файла прошивки: <input type="file" accept=".bin" id="file"/><br>
<div id="percent">Состояние: Ожидание соединения с устройством</div>
<button type="button"id="butStartDFU" disabled="true" onclick="startDFU();">Старт программирования</button>
<br><hr>
Чтение и запись памяти:<br>
Адрес (hex): <input size="8" type="text" id="inputAddr" value="11000000" maxlength="8">
<input type="button" id="butReadAddr" onclick="InfoReadAddr()" disabled="true" value="Читать">
Данные (hex): <input size="40" type="text" id="inputData" value="?" maxlength="32">
<input type="button" id="butWriteData" onclick="WriteData()" disabled="true" value="Записать"><hr>
<input type="button" id="butCmdData" onclick="CmdData()" disabled="true" value="Команда">
<input size="40" type="text" id="inputCmdData" value="55" maxlength="40"><hr>
<button type="button" onclick="clearLog();">Очистить лог</button><br>
<div id="log"></div>
</body></html>